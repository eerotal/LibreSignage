var $ = require('jquery');
var assert = require('ls-assert').assert;

/*
* Convert the dictionary 'v' into a URL query string.
* If 'v' === null, an empty string is returned.
*
* @param {string[]} v An associative array of URL parameters.
*
* @return {string}  The generated query string.
*/
exports.querify = function(v) {
	if (v === null) { return ''; }
	return Object.keys(v).map(
		(k) => {
			return encodeURIComponent(k) + '=' +
			encodeURIComponent(v[k]);
		}
	).join('&');
}

exports.get_GET_parameters = function() {
	/*
	*  Get the HTTP GET parameters in an associative array.
	*/
	var query_str = window.location.search.substr(1);
	var params_strs = [];
	var params = [];
	var tmp = [];

	if (!query_str.length) {
		return [];
	} else {
		params_strs = query_str.split('&');
	}
	for (var i in params_strs) {
		tmp = params_strs[i].split('=');
		params[decodeURIComponent(tmp[0])] = decodeURIComponent(tmp[1]);
	}
	return params;
}

exports.get_cookies = function() {
	var ret = {};
	var tmp = document.cookie.split('; ');
	for (let c of tmp) {
		ret[c.split('=')[0]] = c.split('=')[1];
	}
	return ret;
}

exports.setup_defaults = function() {
	// Setup tooltips.
	$('[data-toggle="tooltip"]').tooltip({
		'delay': {
			'show': 800,
			'hide': 50
		},
		'trigger': 'hover'
	});
}

exports.datetime_to_tstamp = function(date, time) {
	var d = null;
	var t = null;

	if (date == null || date.length == 0) {
		throw new Error(
			`Invalid date string '${date}'.`
		);
	}
	if (time == null || time.length == 0) {
		throw new Error(
			`Invalid time '${time}'.`
		);
	}

	d = date.split('-');
	t = time.split(':');

	if (t.length == 2) {
		t[2] = '00';
	}

	return new Date(
		d[0], '0' + (parseInt(d[1]) - 1).toString(), d[2],
		t[0], t[1], t[2]
	).getTime()/1000;
}

exports.tstamp_to_datetime = function(tstamp) {
	var y, m, d, hour, min, sec;
	var ret = [];
	var date = null;

	if (tstamp == null || tstamp.length == 0) {
		throw new Error(`Invalid timestamp '${tstamp}'.`);
	}

	date = new Date(tstamp*1000);
	y = date.getFullYear();

	m = date.getMonth() + 1;
	if (m.toString().length == 1) {
		m = '0' + m;
	}
	d = date.getDate();
	if (d.toString().length == 1) {
		d = '0' + d;
	}
	hour = date.getHours();
	if (hour.toString().length == 1) {
		hour = '0' + hour;
	}
	min = date.getMinutes();
	if (min.toString().length == 1) {
		min = '0' + min;
	}
	sec = date.getSeconds();
	if (sec.toString().length == 1) {
		sec = '0' + sec;
	}

	ret[0] = y + '-' + m + '-' + d;
	ret[1] = hour + ':' + min + ':' + sec;

	return ret;
}

exports.object_contains = function(a, E, strict = false) {
	/*
	*  Check whether the keys and values in 'a' also exist in 'E'.
	*  if strict == true, keys that exist in 'E' but not in 'a'
	*  are considered invalid. The value of 'strict' also applies
	*  for checking nested objects in a and E. Using strict == true
	*  basically makes this function an 'a === E' equality checker.
	*/
	assert(a !== null);
	assert(a === Object(a));
	assert(E !== null);
	assert(E === Object(E));

	if (strict && Object.keys(a).length !== Object.keys(E).length) {
		return false;
	}

	for (let k of Object.keys(a)) {
		if (!(k in E)) {
			return false;
		} else {
			if (a[k] === Object(a[k]) || Array.isArray(a[k])) {
				if (!exports.object_contains(a[k], E[k], strict)) {
					return false;
				} else {
					continue;
				}
			} else {
				if (a[k] !== E[k]) {
					return false;
				} else {
					continue;
				}
			}
		}
	}
	return true;
}

exports.set_contains = function(a, E) {
	assert(Array.isArray(a));
	assert(Array.isArray(E));

	for (let i of a) { if (!E.includes(i)) { return false; } }
	return true;
}

exports.sets_eq = function(a, b) {
	return exports.set_contains(a, b) && exports.set_contains(b, a);
}

exports.fa_svg_uri = function(type, name) {
	/*
	*  Return a URI pointing to a Font-Awesome SVG icon.
	*/
	return `/libs/@fortawesome/fontawesome-free/svgs/${type}/${name}.svg`;
}

exports.free_multimedia_memory_recursive = function(node) {
	/*
	* Make sure multimedia tag memory is released when tags are removed.
	*
	* This function recursively removes all multimedia sources and reloads
	* the multimedia tags before removing them from the DOM.
	*
	* This function implements the best practices from
	* https://html.spec.whatwg.org/multipage/media.html#best-practices-for-authors-using-media-elements
	*/
	node.querySelectorAll('source').forEach(e => e.remove());
	node.querySelectorAll('video, audio').forEach(e => {
		e.pause();
		e.src = "";
		e.load();
		e.remove();
	});
}
