/*
*  LibreSignage Slide class definition. This class can be used
*  to fetch and handle slide data from a LibreSignage server
*  using the JS APIInterface class.
*/

var assert = require('ls-assert').assert;
var APIEndpoints = require('ls-api').APIEndpoints;
var ANIMATIONS = require('./animations.js').ANIMATIONS;

class Slide {
	constructor(api) {
		assert(api != null, "API object can't be null.");
		this.data = {};
		this.lock_ren_timeout = null;
		this.api = api;
	}

	async load(id, lock, lock_renew) {
		/*
		*  Load the slide with ID 'id'. If 'lock' is true, a
		*  lock is acquired on the slide before loading it.
		*  'lock_renew' is passed to Slide.lock_acquire() for
		*  enabling/disabling automatic lock renewal.
		*/

		/*
		*  If a slide is already loaded and locked,
		*  release that one first.
		*/
		if (
			this.data != null
			&& this.data.id != null
		) { await this.lock_release(null); }

		this.data = {'id': id};
		if (lock) {
			try {
				await this.lock_acquire(lock_renew);
			} catch (e) {
				this.data = {};
				throw e;
			}
		}
		await this.fetch();
	}

	async fetch() {
		/*
		*  Fetch the slide data for a slide. This function expects
		*  the 'id' value in this.data to be already set, ie.
		*  Slide.load() must be called first.
		*/
		assert(this.has('id'), "Slide id not set.");
		console.log(`Slide: Fetch '${this.data.id}'.`);
		let resp = await this.api.call(
			APIEndpoints.SLIDE_GET,
			{ 'id': this.data.id },
		);
		this.set(resp.slide);
	}

	async lock_release() {
		/*
		*  Release the current lock on this slide and disable
		*  automatic lock renewal.
		*/
		assert(this.has('id'), "Slide not loaded.");
		console.log(`Slide: Release lock on '${this.data.id}'.`);
		clearTimeout(this.lock_ren_timeout = null);
		this.data.lock = {};
		return this.api.call(
			APIEndpoints.SLIDE_LOCK_RELEASE,
			{ 'id': this.data.id }
		);
	}

	async lock_acquire(renew) {
		/*
		*  Attempt to acquire a lock on this slide. If 'renew' is
		*  true, automatic lock renewal is set up.
		*/
		assert(this.has('id'), "Slide not loaded.");
		console.log(`Slide: Acquire lock on '${this.data.id}'.`)

		let ren_t = 0;
		let resp = await this.api.call(
			APIEndpoints.SLIDE_LOCK_ACQUIRE,
			{ 'id': this.data.id }
		);
		this.data.lock = resp.lock;

		if (renew) {
			ren_t = (
				this.data.lock.expire
				- Slide.LOCK_RENEWAL_HEADROOM
				- Math.round(Date.now()/1000)
			);

			console.log(
				`Slide: Lock renewal on ${this.data.id} ` +
				`in ${ren_t} seconds.`
			);
			this.lock_ren_timeout = setTimeout(
				async () => {
					try {
						await this.lock_acquire(true);
					} catch (e) {
						this.lock_ren_timeout = null;
						throw e;
					}
				}, ren_t*1000
			);
		}
	}

	is_locked_from_here() {
		return (
			this.data != null
			&& this.data.lock != null
			&& this.data.lock.session_id
				=== this.api.config.session.data.id
			&& this.data.lock.expire >= Date.now()/1000
		);
	}

	is_owned_by_me() {
		let user = this.api.config.session.get_user().get_user();
		return(
			this.data != null
			&& this.data.owner === user
		);
	}

	can_collaborate() {
		let user = this.api.config.session.get_user().get_user();
		return (
			this.data != null
			&& user in this.data.collaborators
		);
	}

	async save() {
		/*
		*  Save this slide.
		*/
		assert(
			this.data.id == null || this.is_locked_from_here(),
			"Can't save an unlocked slide."
		);
		console.log(`Slide: Save '${this.data.id}'.`);
		let resp = await this.api.call(
			APIEndpoints.SLIDE_SAVE,
			this.data
		);
		delete resp.error;
		this.set(resp);
	}

	async remove(id) {
		/*
		*  Remove slide 'id' or the currently loaded slide if
		*  'id' is not supplied. If the currently loaded slide is
		*  removed, the Slide object is also reset.
		*/

		var r_id = "";
		if (id) {
			r_id = id;
		} else if (this.data.id) {
			r_id = this.data.id;
		} else {
			throw new Error("No slide ID specified for removal.");
		}

		console.log(`Slide: Remove '${this.data.id}'.`);
		await this.api.call(
			APIEndpoints.SLIDE_RM,
			{ 'id': r_id }
		);

		if (r_id === this.data.id) {
			this.data = {};
			this.lock_ren_timeout = null;
		}
	}

	async dup() {
		/*
		*  Duplicate this slide. A new Slide object is
		*  returned on success.
		*/
		let resp = await this.api.call(
			APIEndpoints.SLIDE_DUP,
			{'id': this.get('id')}
		);
		let s = new Slide(this.api);
		s.set(resp['slide']);
		return s;
	}

	async remove_asset(name) {
		/*
		*  Remove the asset 'name' from this slide.
		*/
		assert(this.data.id != null, "Unsaved slide.");
		assert(this.is_locked_from_here(), "Slide not locked.");

		await this.api.call(
			APIEndpoints.SLIDE_REMOVE_ASSET,
			{ id: this.data.id, name: name }
		);
		await this.fetch();
	}

	async upload_assets(files) {
		/*
		*  Upload assets to the loaded slide. 'files' is an
		*  object acquired from an HTML <input type="file">
		*  element or a similarly structured object.
		*/
		assert(this.data.id != null, "Unsaved slide.");
		assert(this.is_locked_from_here(), "Slide not locked");

		let data = new FormData();
		if (files.length) {
			for (let i = 0; i < files.length; i++) {
				data.append(i, files[i]);
			}
			data.append('body', JSON.stringify({
				'id': this.data.id
			}));
			await this.api.call(
				APIEndpoints.SLIDE_UPLOAD_ASSET,
				data
			);
			await this.fetch();
		}
	}

	get_asset_uri(name) {
		assert(this.data.id != null, "Unsaved slide.");

		let query = {
			id: this.data.id,
			name: name
		};
		return (
			'/api/endpoint/slide/asset/slide_get_asset.php'
			+ '?' + Slide.array_to_querystring(query)
		);
	}

	get_asset_thumb_uri(name) {
		assert(this.data.id != null, "Unsaved slide.");

		let query = {
			id: this.data.id,
			name: name
		};
		return (
			'/api/endpoint/slide/asset/slide_get_asset_thumb.php'
			+ '?' + Slide.array_to_querystring(query)
		);
	}

	static array_to_querystring(data) {
		return Object.keys(data)
			.map(k => encodeURIComponent(k) + '=' + encodeURIComponent(data[k]))
			.join('&');
	}

	set(data) { Object.assign(this.data, data); }
	clear() { this.data = {}; }
	get(key) { return this.data[key]; }

	has(key) {
		return (
			this.data != null
			&& key in this.data
			&& this.data[key] != null
		);
	}

	anim_hide() { return Slide.ANIMATIONS[this.get('animation')].hide; }
	anim_show() { return Slide.ANIMATIONS[this.get('animation')].show; }
}
Slide.LOCK_RENEWAL_HEADROOM = 30;
Slide.ANIMATIONS = ANIMATIONS;
exports.Slide = Slide;
