var astree = require('./ast.js');
var err = require('./error.js');

const ARGTYPES = {
	'percent': {
		code: 0,
		typestr: 'percent'
	},
	'int': {
		code: 1,
		typestr: 'int'
	},
	'str': {
		code: 2,
		typestr: 'str'
	},
	'rstr': {
		code: 3,
		typestr: 'rstr'
	}
}

var EXPRESSIONS = {
	'root': { has: {}, handle: () => { return ['', '']; } },
	'rstring': {
		has: {'text': ARGTYPES.rstr},
		handle: (arg) => { return [arg['text'], '']; }
	},
	'h': {
		has: { 's': ARGTYPES.percent, },
		handle: (arg) => {
			return [
				`<h1 style="font-size: ${arg['s'].replace('%', '')}vh;">`,
				`</h1>`
			];
		}
	},
	'lead': {
		has: {},
		handle: (arg) => {
			return [
				`<p class="lead">`,
				`</p>`
			]
		}
	}
}

function get_argtype(arg) {
	if (arg.match(/^[0-9]*\%$/)) {
		return ARGTYPES.percent;
	} else if (arg.match(/^[0-9]*$/)) {
		return ARGTYPES.int;
	} else if (
		arg.match(/^'.*'$/)
		|| arg.match(/^".*"$/)
	) {
		return ARGTYPES.str;
	} else {
		return ARGTYPES.rstr;
	}
}

function chk_argtypes(node) {
	// Check node argument types.
	let expr = EXPRESSIONS[node.name];
	let atype = null;
	let typestr = '';
	for (let a in node.data) {
		if (!(a in expr.has)) {
			throw new err.MarkupSyntaxError(
				'EARG',
				node.lexeme,
				`Extra argument '${a}' in tag '${node.name}'.`
			);
		}
		atype = get_argtype(node.data[a]);
		if (expr.has[a].code != atype.code) {
			throw new err.MarkupSyntaxError(
				'ETYPE',
				node.lexeme,
				`Invalid type '${atype.typestr}' for '${a}'. ` +
				`Expected '${expr.has[a].typestr}'.`
			);
		}
	}
	for (let a in expr.has) {
		if (!node.data || !(a in node.data)) {
			throw new err.MarkupSyntaxError(
				'EARG',
				node.lexeme,
				`Missing argument '${a}' in tag '${node.name}'.`
			);
		}
	}
}

function eval_node(node) {
	let buf = '';
	let expr = null;
	let out = null;

	if (!(node.name in EXPRESSIONS)) {
		throw new err.MarkupSyntaxError(
			'ETAG',
			node.lexeme,
			node.name
		);
	}
	expr = EXPRESSIONS[node.name];
	chk_argtypes(node);

	out = expr.handle(node.data);
	buf += out[0];
	for (let n of node.nodes) {
		buf += eval_node(n);
	}
	buf += out[1];
	return buf;
}

module.exports.eval = function(ast) {
	return eval_node(ast.nodes);
}
